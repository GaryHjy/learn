# HTTP缓存机制

当访问chrome中的URL时，页面上的HTML和其他资产（如图像）将本地存储在内存和磁盘缓存中。Chrome将首先使用内存缓存，因为它的速度快得多，但它也会将页面存储在磁盘缓存中，以防您退出浏览器或它崩溃，因为磁盘缓存是持久的。

## 分类

- 强缓存

**expires**

HTTP1.0规定的响应头，对应一个未来的时间戳。客户端第一次请求之后，服务端下发Expires响应头字段，当客户端再次需要请求时，先会对比当前时间和Expires头中设置的时间。如果当前时间早于Expires时间，那么直接使用缓存数据，反之则需要再次发送请求，更新数据。

```
expires: Sun, 02 Aug 2020 11:25:34 GMT
```

缺点：
  1. 可能会因为服务器和客户端的GMT时间不同，出现偏差
  2. 如果修改了本地时间，那么客户端日期可能不准确
  3. 写法太复杂，字符串多个空格，少个字母，都会导致非法属性从而设置失效

**cache-control**

HTTP1.1版本中，服务端使用Cache-control这个响应头，这个头部更加强大，它具有更多不同的值：
```
private: 表示私有缓存，不能被共有缓存代理服务器缓存，不能在用户共存，可被用户的浏览器缓存
public：表示共有缓存，可被代理服务器缓存，比如CDN，允许多用户间共享
max-age：值以秒为单位，表示缓存的内容会在该值后过期
no-cache：表示不进行强缓存验证, 而是用协商缓存来验证。
no-store：所有内容都不会被缓存
must-revalidate：告诉浏览器，你必须再次验证检查信息是否过期，返回的代号就不是200而是304了
```

```js
//Response Headers
Cache-Control: private, max-age=0, must-revalidate
// 表示该资源只能被浏览器缓存，而不能被代理缓存。max-age标识为0，说明该缓存资源立即过期，must-revalidate告诉浏览器，需要验证文件是否过期，接下来可能会使用协商缓存进行判断
```

**HTTP规定，如果Cache-control的max-age和Expires同时出现，那么max-age的优先级更高，他会默认覆盖掉expires**

- 协商缓存

协商缓存概括来说就是浏览器会携带缓存标识(tag)向服务器发送请求, 服务器会根据缓存标识(tag)来决定是否使用缓存.

过程：在浏览器端，当对某个资源的请求没有命中强缓存时，浏览器会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的HTTP状态为304

返回结果：

  协商缓存生效时，返回304和Not Modified（空响应体）

  协商缓存失败时，返回200和响应体

**Last-Modified, If-Modified-Since**

```
1. 浏览器第一次请求资源，服务端在返回资源的Response Headers中加入Last-Modified字段，这个字段表示这个资源在服务器的最近修改时间
2. 浏览器收到响应，并记录Last-Modified这个响应头的值为T
3. 当浏览器再次向服务端请求该资源时，请求头加上If-Last-Modified-Since的header，这个If-Modified-Since的值是上一次请求该资源时，后端返回的Last-Modified响应头值T
4. 服务端再次收到请求，根据请求头If-Modified-Since的值T，判断相关资源是否在T时间后有变化；如果没有变化则返回304 Not Modified，且并不返回资源内容，浏览器使用资源缓存值；如果有变化，则正常返回资源内容，且更新Last-Modified响应头内容
```

缺点：
  1. 如果客户端的时间不准确，就会导致判断不可靠
  2. Last-Modified标注的最后修改只能精确到秒级，如果文件在1秒内修改了多次，不能准确的标注文件的修改时间
  3. 一些文件也许会周期性的更改，但是它的内容并不改变，仅仅改变的修改时间，这时候使用Last-Modified不是很适合了

**ETag If-None-Match**

```
1. 浏览器第一次请求资源，服务端在放回资源的Response Headers中加入ETag，ETag能够弥补Last-Modified的问题，因为ETag生成的过程类似文件hash值，ETag是一个字符串，不同文件内容对应不同ETag值
2. 浏览器收到响应，记录ETag这个响应头的值为E
3. 浏览器再次与服务器请求这个资源时，在请求头上加上If-None-Match，值为ETag这个响应头的值E
4. 服务端再次收到请求，根据请求头If-None-Match的值E，根据资源生成一个新的ETag，对比E和新的ETag：如果两个值相同，则说明资源没有变化，返回304 Not Modified，同时携带着新的ETag响应头；如果俩值不同，就正常返回资源内容，这个也更新ETag响应头
5. 浏览器收到304的响应后，就会从缓存中加载资源
```
ETag的生成策略，实际上规范并没有强制说明，这就取决于各大厂商或平台的自主实现方式了。

```
ETag和Last-Modified优先级
如果他们组合出现在请求头中，我们会优先采用ETag策略。同时ETag也有自己的问题：相同的资源，在两台服务器产生的ETag是不是相同的，所有对于使用服务器集群来处理请求的网站来说，ETag的匹配概率会大幅降低。所以在这种情况下，使用ETag来处理缓存，反而会有更大的开销。
```

## 总结

优先级
```
Cache-control > Expires > ETag > Last-Modified
强制缓存优先级最高，并且资源的改动在缓存有效期内浏览器都不会发送请求，因此强制缓存的使用适用于大型且不易修改的的资源文件，例如第三方 CSS、JS 文件或图片资源。如果更加灵活的话，我们也可以为文件名加上 hash 进行版本的区分。
```

协商缓存灵活性高，适用于数据的缓存，采用ETag标识进行对比灵活度最高，也最为可靠。对于数据的缓存，我们可以重点考虑存入内存中，因为内存加载速最快，并且数据体积小。