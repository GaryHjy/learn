# 垃圾回收机制

JavaScript具有自动垃圾回收机制，也就是说，执行环境负责管理代码执行过程中遇到使用的内存。

- 原理

找出那些不再继续使用的变量，然后释放其占用的内存，垃圾收集器会按照固定的时间间隔（或代码中预定的收集时间），周期性的执行这一操作。

## 新生代的回收

V8把堆内存分为两部分进行处理————新生代内存和老生带内存。

新生代内存：临时分配的内存，存活时间短

老生代内存：常驻内存，存活时间长

- V8内存的回收策略

对于新生代的内存，变量存活时间段，来了马上就走，不容易产生太大的内存负担，因此可以将新生代的内存空间设的足够小

新生代回收原理：
1. 首先将新生代的内存空间一分为二（From：表示正在使用的内存，To：目前闲置的内存）
2. 当垃圾进行回收时，会将From部分的对象检查一遍，如果存在存活的对象会直接复制到To内存中（按照顺序从头放置），如果是非存活对象直接回收
3. 当所有的From中的存活对象按照顺序进入To内存之后，From和To两者的角色对调

疑问：为什么调换位置的时候需要按顺序排列？

堆内存是连续分配的，当垃圾回收机制回收掉无用的对象之后，会出现堆内存零零散散的，这样子会导致如果稍微大一点的对象没有办法进行空间分配，这种零散的空间叫做**内存碎片**。

为了解决这个问题，新生代的垃圾回收机制制定了**Scavenge算法**。

Scavenge算法的劣势也非常明显，就是内存会占用新生代内存的一半，但是它只存放生命周期短的对象，这种对象一般很少，因此时间性能非常优秀。

## 老生代的回收

如果新生代的变量经过了多次回收之后依然存在，那么就会被放入到老生代内存中，这种现象叫做**晋升**

- 触发晋升的情况

```
1. 已经经历过一次Scavenge回收
2. To（闲置）空间的内存占用超过25%
```

老生代的垃圾回收机制当中，老生代累积的变量空间一般都是很大的，所以不能使用**Scavenge**算法，浪费一半空间不说，对于庞大的内存空间复制其实挺损耗性能的。

老生代回收过程：
1. 进行**标记清理**，首先会遍历堆中的所有对象，对它们做上标记，然后对于代码环境中使用的变量以及被强引用的变量取消标记，剩下的就是要删除的变量了，在随后的清除阶段进行空间的回收
2. 整理碎片，V8的解决方式非常简单粗暴，在清理阶段结束后，把存活的对象全部往一段靠拢（由于是移动对象，它的执行速度不可能很快，事实上也是整个过程中最耗时间的。）

## 增量标记

由于JS的单线程机制，V8在进行垃圾回收的时候，不可避免的会阻塞业务逻辑的执行，如果新生代的垃圾回收任务很重，那么耗时会非常可怕，严重影响应用的性能。为了避免这个问题，

增量标记的方案：

将一口气完成标记任务分为很多小的部分完成，每做完一个小的部分就“歇”一下，然后让js应用逻辑执行一会儿，然后再执行下面的部分，如此循环，直到标记阶段完成才进入内存碎片的整理上面来。


经过增量标记之后，垃圾回收过程对JS应用的阻塞时间减少到原来的1/6，



