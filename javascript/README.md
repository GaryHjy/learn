### 执行环境

执行环境（execution context），执行上下文。

执行环境定义函数或变量有权访问的其它数据，决定它们各自的行为。

每个环境都有一个与之关联的**变量对象（variable object）**，环境中定义的所有变量和函数都会保存在对个对象中。

某个执行环境中的所有代码执行完毕后，该环境会被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出————例如关闭网页或浏览器————时才会被销毁）

每个函数都有自己的**执行环境**，当执行流进入一个函数时，函数的环境就被被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。


备注：资料来源红宝书（p73），4.2 执行环境及作用域

### 作用域

作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。换句话说，作用域决定了代码区块中变量和其他资源的可见性。

作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。

- 全局作用域

在代码中任何地方都能访问到的对象拥有全局作用域。

- 函数作用域

函数作用域，是指声明在函数内部的变量，和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部。

### 作用域链

当代码在一个环境中执行时，会创建变量对象的一个**作用域链（scope chain）**
作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。
标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域的前端开始，然后逐渐地向后回溯，直到找到标识符为止（如果找不到标识符，通常会导致错误发生）


### 代码执行过程

代码执行的整个过程说起来就像一条生产流水线。第一道工序是在预编译阶段创建变量对象（Variable Object），此时只是创建，而未赋值。到了下一道工序代码执行阶段，变量对象转为激活对象（Active Object），即完成 VO → AO。此时，作用域链也将被确定，它由当前执行环境的变量对象和所有外层已经完成的激活对象组成。这道工序保证了变量和函数的有序访问，即如果当前作用域中未找到变量，则继续向上查找直到全局作用域。

### this

- this指向

流传的说法：谁调用它，this 就指向谁。  
总结：this 的指向，是在调用函数时根据 **执行上下文（执行环境）** 所动态确定的。

```js
function Foo() {
  getName = function() {
    console.log(1);
  }
  return this;
}

Foo.getName = function() {
  console.log(2);
}

Foo.prototype.getName = function() {
  console.log(3);
}

var getName = function() {
  console.log(4);
}

function getName() {
  console.log(5);
}

Foo.getName();
getName();
Foo().getName();
new Foo.getName();
new Foo().getName();

```
输出结果
```js
Foo.getName(); // 2  函数的静态方法
getName(); // 4  // 变量提升
Foo().getName(); //1  // 函数作用域
new Foo.getName(); // 2 // 函数的静态方法 new优先级
new Foo().getName(); // 3 // 实例方法

```

- 优先级

```
new 绑定 > 显式绑定 > 隐式绑定 > 默认绑定
```

- 构造函数和 this（new绑定）

new 操作符调用构造函数，具体做了什么?

```js
// 创建一个新的对象；
// 将构造函数的 this 指向这个新对象；
// 为这个对象添加属性、方法等；
// 最终返回新对象。
var obj  = {}
obj.__proto__ = Foo.prototype
Foo.call(obj)
```

如果在构造函数中出现了显式 return 的情况，那么需要注意分为两种场景
```js
function Foo(){
    this.user = "foo"
    const o = {}
    return o
}
const instance = new Foo()
console.log(instance.user)
```
将会输出 undefined，此时 instance 是返回的空对象 o。
```js
function Foo(){
    this.user = "foo"
    return 1
}
const instance = new Foo()
console.log(instance.user)
```
将会输出 foo instance 是返回的目标对象实例 this。

结论：如果构造函数中显式返回一个值，且返回的是一个对象，那么 this 就指向这个返回的对象；如果返回的不是一个对象，那么 this 仍然指向实例。

修改this指向的方法

```
注：箭头函数的绑定无法被修改
```

### 高阶函数

- 函数参数是一个函数（回调函数也是高阶函数）
- 函数返回一个函数

### 类型判断

```
typeof
缺点：无法判断对象类型
```

```
constructor
缺点：无法判断是谁构造出来，不能判断undefined和null，并且它是不安全的，因为constructor的指向是可以被改变
```

```
instanceof
缺点：不能识别出基本的数据类型 number、boolean、string、undefined、null、Symbol
```

```
Object.prototype.toString
较全的判断js的数据类型
```

### 闭包

函数嵌套函数时，内层函数引用了外层函数作用域下的变量，并且内层函数在全局环境下可访问，就形成了闭包。
闭包使用不当，极可能引发内存泄漏，需要格外注意。

### 内存泄漏

内存泄漏是指内存空间明明已经不再被使用，但由于某种原因并没有被释放的现象。这是一个非常”玄学“的概念，因为内存空间是否还在使用，某种程度上是不可判定问题，或者判定成本很高。内存泄漏危害非常直观：它会导致程序运行缓慢，甚至奔溃。d
